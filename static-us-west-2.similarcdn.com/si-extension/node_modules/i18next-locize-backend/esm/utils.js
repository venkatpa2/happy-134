var arr = [];
var each = arr.forEach;
var slice = arr.slice;
export function defaults(obj) {
    each.call(slice.call(arguments, 1), function(source) {
        if (source) {
            for (var prop in source) {
                if (obj[prop] === undefined) obj[prop] = source[prop];
            }
        }
    });
    return obj;
}
export function debounce(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this;
        var args = arguments;
        var later = function later() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};

function getLastOfPath(object, path, Empty) {
    function cleanKey(key) {
        return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
    }
    var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
    while (stack.length > 1) {
        if (!object) return {};
        var key = cleanKey(stack.shift());
        if (!object[key] && Empty) object[key] = new Empty();
        object = object[key];
    }
    if (!object) return {};
    return {
        obj: object,
        k: cleanKey(stack.shift())
    };
}
export function setPath(object, path, newValue) {
    var _getLastOfPath = getLastOfPath(object, path, Object),
        obj = _getLastOfPath.obj,
        k = _getLastOfPath.k;
    obj[k] = newValue;
}
export function pushPath(object, path, newValue, concat) {
    var _getLastOfPath2 = getLastOfPath(object, path, Object),
        obj = _getLastOfPath2.obj,
        k = _getLastOfPath2.k;
    obj[k] = obj[k] || [];
    if (concat) obj[k] = obj[k].concat(newValue);
    if (!concat) obj[k].push(newValue);
}
export function getPath(object, path) {
    var _getLastOfPath3 = getLastOfPath(object, path),
        obj = _getLastOfPath3.obj,
        k = _getLastOfPath3.k;
    if (!obj) return undefined;
    return obj[k];
}
var regexp = new RegExp('{{(.+?)}}', 'g');

function makeString(object) {
    if (object == null) return '';
    return '' + object;
}
export function interpolate(str, data, lng) {
    var match, value;

    function regexSafe(val) {
        return val.replace(/\$/g, '$$$$');
    }
    while (match = regexp.exec(str)) {
        value = match[1].trim();
        if (typeof value !== 'string') value = makeString(value);
        if (!value) value = '';
        value = regexSafe(value);
        str = str.replace(match[0], data[value] || value);
        regexp.lastIndex = 0;
    }
    return str;
}
export function isMissingOption(obj, props) {
    return props.reduce(function(mem, p) {
        if (mem) return mem;
        if (!obj || !obj[p] || typeof obj[p] !== 'string' || !obj[p].toLowerCase() === p.toLowerCase()) {
            var err = "i18next-locize-backend :: got \"".concat(obj[p], "\" in options for ").concat(p, " which is invalid.");
            console.warn(err);
            return err;
        }
        return false;
    }, false);
}
export function optionExist(obj, props) {
    return !isMissingOption(obj, props);
}
export function defer() {
    var res;
    var rej;
    var promise = new Promise(function(resolve, reject) {
        res = resolve;
        rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
}