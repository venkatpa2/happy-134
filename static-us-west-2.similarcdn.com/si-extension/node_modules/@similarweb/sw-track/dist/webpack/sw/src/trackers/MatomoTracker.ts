import swLog from "@similarweb/sw-log";
import * as isEmpty from "lodash.isempty";
import { BaseTracker } from "./BaseTracker";
import {
  CustomDimensions,
  ICustomDimensionData,
  ICustomDimensionPath,
  IDimensions,
  TrackModel,
  PathCustomDimensions,
  TrackingEvent,
  CustomAttribute,
  Primitive,
  SerializableObject,
} from "./ITrack";
import { tryParse } from "../utils/TryParse";
export abstract class MatomoTracker extends BaseTracker {
  private readonly maxRetriesNumber = 10;
  private readonly minRetriesNumberForLogging = 3;
  private readonly timeToWaitBetweenRetries = 1000;

  private customUrl = "";

  protected trackEventInternal({ category, action, cid, name, trackId, location, value }: TrackModel): void {
    name = [`cid=${cid ?? this.generateId()}`, name, trackId, location].filter((a) => a).join("/");
    this.resilientTrackEvent(category instanceof Array ? category.filter((a) => a).join("/") : category, action, name, value);
  }

  protected setCustomDimensionsWithoutOverride(
    customAttributes: Record<CustomAttribute, Primitive>,
    customDataDimensionID: number,
    customDimensionValue: SerializableObject | string,
  ) {
    const customAttributesKeys = Object.keys(customAttributes);
    const newCustomDimensionValue =
      typeof customDimensionValue === "object"
        ? customAttributesKeys.reduce((result, key) => {
            const superPropertyValue = customDimensionValue[key];
            if (superPropertyValue) {
              this.propertyAlreadyExistsWarn(key, superPropertyValue);
              return result;
            }
            return { ...result, [key]: customAttributes[key] };
          }, customDimensionValue)
        : customDimensionValue;
    this.setCustomDimension(customDataDimensionID, newCustomDimensionValue);
  }

  protected dispatchTrackEventInternal(
    event: TrackingEvent,
    action: string,
    eventName: string,
    customAttributes: Record<CustomAttribute, Primitive>,
  ) {
    if (!this.isMatomoLoaded()) return false;
    const customDataDimensionID = this.getDimensions().custom_data;
    const customDimensionValue = this.getCustomDimensionValue(customDataDimensionID);

    this.setCustomDimensionsWithoutOverride(customAttributes, customDataDimensionID, customDimensionValue);

    const { eventName: name, trackId, location } = this.toInternalEventConvention(eventName);
    this.trackEventInternal({
      category: event,
      trackId,
      location: location?.join("/"),
      action,
      name,
    });

    // reset the initial dimension value
    this.setCustomDimension(customDataDimensionID, customDimensionValue);
  }

  private resilientTrackEvent(category: string, action: string, name: string, value?: number, retryNumber = 1) {
    const success = this.tryTrackEvent(category, action, name, value);

    if (success) {
      if (retryNumber > this.minRetriesNumberForLogging) {
        swLog.serverLogger(
          `[Matomo] Track event succeeded, retry number: ${retryNumber}. 
          category: ${category},
          action: ${action},
          name: ${name},
          value: ${value}.`,
          null,
          "Info",
          "Matomo",
        );
      }
      return;
    }

    if (retryNumber < this.maxRetriesNumber) {
      setTimeout(
        function () {
          this.resilientTrackEvent(category, action, name, value, retryNumber + 1);
        }.bind(this),
        this.timeToWaitBetweenRetries,
      );
    } else {
      swLog.serverLogger(
        `[Matomo] Failed to track event.
        category: ${category},
        action: ${action},
        name: ${name},
        value: ${value}.`,
        null,
        "Debug",
        "Matomo",
      );
    }
  }

  private tryTrackEvent(category: string, action: string, name: string, value?: number): boolean {
    if (!this.isMatomoLoaded()) return false;

    try {
      this.paq().push(["trackEvent", category, action, name, value]);
      this.getBuffer().add(["trackEvent", category, action, name, value, this.customUrl]);
      return true;
    } catch (e) {
      swLog.serverLogger(
        `[Matomo] Error in Matomo analytics (event). ${e.message}.
        category: ${category},
        action: ${action},
        name: ${name},
        value: ${value}.`,
        e,
        "Debug",
        "Matomo",
      );
      return false;
    }
  }

  protected trackPageViewInternal(customDimsData: ICustomDimensionData): void {
    this.resilientTrackPageView(customDimsData);
  }

  private resilientTrackPageView(customDimsData: ICustomDimensionData, retryNumber = 1) {
    const success = this.tryTrackPageView(customDimsData);

    if (success) {
      if (retryNumber > this.minRetriesNumberForLogging) {
        swLog.serverLogger(
          `[Matomo] Track page view succeeded, retry number: ${retryNumber}. data: ${JSON.stringify(customDimsData)}.`,
          null,
          "Info",
          "Matomo",
        );
      }
      return;
    }

    if (retryNumber < this.maxRetriesNumber) {
      setTimeout(
        function () {
          this.resilientTrackPageView(customDimsData, retryNumber + 1);
        }.bind(this),
        this.timeToWaitBetweenRetries,
      );
    } else {
      swLog.serverLogger(`[Matomo] Failed to track page view. data: ${JSON.stringify(customDimsData)}.`, null, "Debug", "Matomo");
    }
  }

  private tryTrackPageView(customDimsData: ICustomDimensionData): boolean {
    if (!this.isMatomoLoaded()) return false;

    try {
      this.paq().push(["setCustomUrl", window.location.href]);
      this.setCustomDimensions(customDimsData);
      this.paq().push(["trackPageView"]);
      return true;
    } catch (e) {
      swLog.serverLogger(
        `[Matomo] Error in Matomo analytics (page view). ${e.message}. data: ${JSON.stringify(customDimsData)}`,
        e,
        "Debug",
        "Matomo",
      );
      return false;
    }
  }

  protected healthCheckInternal(): void {
    if (!this.isMatomoLoaded()) {
      swLog.serverLogger("[Matomo] Matomo is not loaded", null, "Debug", "Matomo");
    }
  }

  /**
   * getter for the native tracker
   */
  protected abstract paq(): any[];

  /**
   * should the tracker be buffered
   */
  protected abstract shouldBuffer(): boolean;

  /**
   * getter for the search params object
   */
  protected abstract searchParams(): any;

  /**
   * getter for the custom dimensions ids
   */
  protected getDimensions(): IDimensions {
    return CustomDimensions;
  }

  private isMatomoLoaded() {
    const paq = this.paq();
    return paq && !(Array.isArray(paq) && paq.length > 5);
  }

  private setCustomDimension(customDimensionId, customDimensionValue): void {
    this.paq().push(["setCustomDimension", customDimensionId, this.formatValue(customDimensionValue)]);
  }

  protected getCustomDimensionValue(customDimensionId): SerializableObject | string {
    let customDimension;
    this.paq().push([
      function () {
        customDimension = this.getCustomDimension(customDimensionId);
      },
    ]);
    return tryParse(customDimension);
  }

  private formatValue(customDimensionValue): string {
    return typeof customDimensionValue === "object" ? JSON.stringify(customDimensionValue) : customDimensionValue;
  }

  private deleteCustomDimension(customDimensionId): void {
    this.paq().push(["deleteCustomDimension", customDimensionId]);
  }

  private setCustomDimensions(customDimsData: ICustomDimensionData): void {
    const dimensions = this.getDimensions();

    Object.keys(dimensions).forEach((key) => {
      const value = customDimsData && customDimsData[key];
      const type = typeof value;

      const isObject = type === "object" && !isEmpty(value);
      const hasValue = isObject || type === "boolean" || type === "string";
      const dimensionId = dimensions[key];

      if (!hasValue) {
        this.deleteCustomDimension(dimensionId);
        return;
      }

      if (isObject && this.isPath(value)) {
        Object.keys(value).forEach((pathKey) => {
          const pathKeyWithPrefix = `path_${pathKey}`;
          const pathId = PathCustomDimensions[pathKeyWithPrefix];

          if (!!value[pathKey]) {
            const pathValue = {};
            pathValue[pathKey] = value[pathKey];

            this.setCustomDimension(pathId, JSON.stringify(pathValue));
          }
        });
      } else {
        this.setCustomDimension(dimensionId, value);
      }
    });
  }

  private isPath(object: any): object is ICustomDimensionPath {
    return "section" in object;
  }
}
