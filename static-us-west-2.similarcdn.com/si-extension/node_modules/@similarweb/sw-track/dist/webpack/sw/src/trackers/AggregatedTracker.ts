import { TrackBuffer } from "../utils/TrackBuffer";
import { CustomAttribute, ICustomDimensionData, ITrack, TrackingEvent, TrackModel, Primitive } from "./ITrack";

/**
 * A tracker that runs an a list of trackers for every method.
 * Trackers are run if ITrack.enable() return true;
 */
export class AggregatedTracker implements ITrack {
  private trackers: ITrack[] = [];

  constructor(trackers: ITrack[]) {
    this.trackers = trackers.slice();
  }
  /**
   * @deprecated please use the AggregatedTracker.dispatchTrackEvent method;
   */
  public trackEvent(category: string, action: string, name: string, value?: number): void {
    this.trackers.forEach((tracker: ITrack) => tracker.trackEvent(category, action, name, value));
  }

  public dispatchTrackEvent(
    event: TrackingEvent,
    action: string,
    eventName: string,
    customAttributes?: Record<CustomAttribute, Primitive>,
  ): void {
    this.trackers.forEach((tracker: ITrack) => tracker.dispatchTrackEvent(event, action, eventName, customAttributes));
  }

  public trackEvent2(trackPayload: TrackModel): void {
    this.trackers.forEach((tracker: ITrack) => tracker.trackEvent2(trackPayload));
  }

  public trackPageView(customDimsData: ICustomDimensionData): void {
    this.trackers.forEach((tracker: ITrack) => tracker.trackPageView(customDimsData));
  }

  public healthCheck(): void {
    this.trackers.forEach((tracker: ITrack) => tracker.healthCheck());
  }

  public getBuffer(): TrackBuffer {
    throw new Error("Not implemented: call getBuffer() on the individual tracker");
  }

  public runCustomAction(action: string, ...args): void {
    this.trackers.forEach((tracker: ITrack) => tracker.runCustomAction.apply(tracker, [action, ...args]));
  }

  public getTrackers(): Array<ITrack> {
    return { ...this.trackers };
  }
}
