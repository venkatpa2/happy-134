declare const SW_ENV: { debug: boolean, apiCache: boolean };

enum LogLevel {Fatal, Error, Warn, Info, Debug, Trace}

export interface ISwLog {
    serverLogger: (message: string, e?: Error, level?: string, logSource?: string, encryptedEmail?: string) => Promise<Response>;
    exception: (message: string, e: Error) => Promise<Response>;
    mute: () => void;
    unmute: () => void;
}

const METHODS = ["debug", "error", "info", "log", "warn", "dir", "dirxml", "table", "trace", "assert", "count", "markTimeline", "profile", "profileEnd",
    "time", "timeEnd", "timeStamp", "timeline", "timelineEnd", "group", "groupCollapsed", "groupEnd", "clear"];
const IGNORE_DEBUG = ["error", "warn"];
let mute = false;

// console wrapper
const logger: ISwLog = {
    /**
     *
     * A log call sent tpo the backend
     * @param message
     * @param e
     * @param level
     * @param logSource
     * @param encryptedEmail
     * @param extraHeaders
     * The following are the allowed log levels (in descending order):
     * Fatal, Error, Warn, Info, Debug, Trace
     * @returns a {Promise<Response>} to the server log fetch
     */
    serverLogger: (message, e, level = "Error", logSource = "frontend", encryptedEmail = '', extraHeaders = {}) => {
        const stack = (e && e.stack) || '';
        const headers = new Headers({
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json",
            ...extraHeaders,
        });
        // post error to the server
        return fetch("/api/exception", {
            method: "POST",
            credentials: "include",
            headers,
            body: JSON.stringify({
                message,
                stack,
                url: window.location.href,
                level,
                logSource,
                encryptedEmail
            }),
        });
    },

    /**
     *
     * log an Exception locally, and in the backend
     * @param message
     * @param e
     * @returns a {Promise<Response>} to the server log fetch
     */
    exception(message, e) {
        if (!e) {
            this.error(message);
            return;
        }

        const msg = message + ": " + e.message;
        this.error(msg, e);
        return this.serverLogger(msg, e);
    },
    mute() {
        mute = true;
    },
    unmute() {
        mute = false;
    }
};

// init stubs
for (let i = 0; i < METHODS.length; i++) {
    logger[METHODS[i]] = () => {
    };
}

// try window.console
if (typeof window !== "undefined" && typeof window.console !== "undefined") {
    const impl = window.console;
    for (const name in impl) {
        const func = impl[name];
        if (typeof func === "function" && typeof func.apply === "function") {
            // attach impl
            (funcName => {
                logger[funcName] = (...args) => {
                    if (!mute && (SW_ENV.debug || IGNORE_DEBUG.indexOf(funcName) > -1)) {
                        impl[funcName].apply(impl, args);
                    }
                };
            })(name);
            /* jshint loopfunc:false */
        }
    }
}

export const SwLog = logger as ISwLog & Console;
export default SwLog as ISwLog & Console;



// WEBPACK FOOTER //
// ./src/index.ts